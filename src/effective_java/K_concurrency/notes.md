Item 78: Synchronize access to shared mutable data

Item 79: Avoid excessive synchronization

Item 80: Prefer executors, tasks, and streams to threads

        We can use Java ExecutorService to create a single thread, a pool of threads, or a scheduled pool of threads. 
        The Executors class provides factory methods to instantiate an ExecutorService as follow
        Executors.{newSingleThreadExecutor,newFixedThreadPool(..),newScheduledThreadPool(..)}

        We can assign tasks to the ExecutorService using several methods including execute(), submit(), invokeAny() and invokeAll().
        
        Future interface has methods to obtain the result generated by an object. It represents the result of an 
        asynchronous computation. The result can only be retrieved using method get() when the computation has 
        completed, blocking if necessary until it is ready.

Item 81: Prefer concurrency utilities to wait and notify
    
        Given the difficulty to of using wait and notify correctly, 
        it is better to to use high level concurrency utilities instead.
        In summary, using wait and notify directly is like programming in 
        “concur- rency assembly language,” as compared to the higher-level 
        language provided by java.util.concurrent. There is seldom, 
        if ever, a reason to use wait and notify in new code. 
            
Item 82: Document thread safety

Item 83: Use lazy initialization judiciously

        Field accessed only a fraction of the instances of a class and it is costly to initialize, lazy
        may be worthwhile.

Item 84: Don’t depend on the thread scheduler

